// 所有权规则：
// 1. Rust 中的每一个值都有一个 所有者（owner）。
// 2. 值在任一时刻有且只有一个所有者。
// 3. 当所有者（变量）离开作用域，这个值将被丢弃。
fn main() {
    // 变量与数据交互的方式（一）：移动
    let s1 = String::from("hello");
    let s2 = s1;
    // 为了确保内存安全，在 let s2 = s1; 之后，
    // Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。

    // 变量与数据交互的方式（二）：克隆
    let s1 = String::from("hello");
    let s2 = s1.clone();
    println!("s1 = {}, s2 = {}", s1, s2);
    // 如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
    // 哪些类型实现了 Copy trait 呢？
    // 任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。
    // 如下是一些 Copy 的类型：
    // 1. 所有整数类型，比如 u32。
    // 2. 布尔类型，bool，它的值是 true 和 false。
    // 3. 所有浮点数类型，比如 f64。
    // 4. 字符类型，char。
    // 5. 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。
}
